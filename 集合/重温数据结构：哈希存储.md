###[点击查看 Java 集合框架深入理解 系列](http://blog.csdn.net/u011240877/article/category/6447444)， - ( ゜- ゜)つロ 乾杯~ 

>在学习 HashMap 前，我们先来温习下 Hash(哈希) 的概念。

-------------

在介绍一些集合时，我们总强调需要重写某个类的 equlas() 方法和 hashCode() 方法，确保唯一性。这里的 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程称作 hash。

##什么是 Hash

Hash（哈希），又称“散列”，

##几种常见的哈希函数

##为什么要有 Hash

我们通常使用数组或者链表来存储元素，一旦存储的内容数量特别多，需要占用很大的空间，而且在**查找某个元素**是否存在的过程中，数组和链表都需要挨个循环比较，而通过 哈希 计算，可以大大**减少比较次数**。

###举个栗子：

现在有 4 个数 {2,5,9,13}，需要查找 13 是否存在。

####1.使用数组存储，需要新建个数组 new int[]{2,5,9,13}，然后需要写个循环遍历查找：

        int[] numbers = new int[]{2,5,9,13};
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == 13){
                System.out.println("find it!");
                return;
            }
        }

这样需要遍历 4 次才能找到，时间复杂度为 O(n)。

####2.而假如存储时先使用哈希函数进行计算，这里我随便用个函数：

     H[key] = key % 3;

四个数 {2,5,9,13} 对应的哈希值为：

     H[2] = 2 % 3 = 2;
     H[5] = 5 % 3 = 2;
     H[9] = 9 % 3 = 0;
     H[13] = 13 % 3 = 1;

然后把它们存储到对应的位置。

当要查找 13 时，只要先使用哈希函数计算它的位置，然后去那个位置查看是否存在就好了，本例中只需查找一次，时间复杂度为 O(1)。

###因此可以发现，哈希 其实是一股脑存储的一种优化，先进行分类，然后查找时按照这个对象的分类去找，自然比从全部数据里查找速度要快。

比如你和我一样是个剁手族买书狂，家里书一大堆，如果书存放时不分类直接摆到书架上（数组存储），找某本书时可能需要脑袋从左往右从上往下转好几圈才能发现；如果存放时按照类别分开放，技术书、小说、文学等等分开（按照某种哈希函数计算），找书时只要从它对应的分类里找，自然省事多了。

##哈希冲突


 


##Thanks
http://www.nowamagic.net/librarys/veda/detail/1273

http://www.nowamagic.net/librarys/veda/detail/799

