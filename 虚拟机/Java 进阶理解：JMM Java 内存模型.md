
>Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。

##part1
在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

那么Java内存模型规定了哪些东西呢，它**定义了程序中变量的访问规则**，往大一点说是定义了程序执行的次序。

注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。

也就是说，在java内存模型中，也会存在**缓存一致性问题**和**指令重排序**的问题。

Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。


从上面可以看出，Java内存模型**只保证了基本读取和赋值是原子性操作**，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

##part2
Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

8条 happens-before 原则见《深入理解Java虚拟机》

##堆内存与栈内存的区别


http://www.cnblogs.com/dolphin0520/p/3920373.html

https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4

http://blog.csdn.net/reliveit/article/details/46940989