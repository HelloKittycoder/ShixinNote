

1、  Java垃圾回收机制有几种方式？

Thinking ing java 一书中也对垃圾回收做了一些小结

主要有以下几种算法：

引用计数
标记算法
增量收集

为什么程序员要学GC
http://blog.csdn.net/turingbooks/article/details/52298380

垃圾回收算法的实现  试读
http://www.ituring.com.cn/tupubarticle/10952

---------------------------------------
什么是GC？

GC 是 Garbage Collection 的简称，中文称为“垃圾回收”。在现实世界中，“垃圾”指的是那些不读的书、不穿的衣服等不用的东西。在 GC 中，“垃圾”的定义也是如此，GC 把程序不用的内存空间视为垃圾。

GC 要做两件事。

找到内存空间里的垃圾；
回收垃圾，让程序员能再次利用这部分空间。
满足这两项功能的程序就是 GC。那么GC 到底会给程序员带来怎样的好处呢？

没有GC的世界

在没有 GC 的世界里，程序员必须自己手动进行内存管理，必须清楚地确保必要的内存空间，释放不要的内存空间。

程序员在手动进行内存管理时，申请内存尚不存在什么问题，但在释放不要的内存空间时，就必须一个不漏地释放。这非常地麻烦。如果忘记释放内存空间，该内存空间就会发生内存泄露 ，即无法被使用，但它又会持续存在下去。如果将发生内存泄露的程序放着不管，总有一刻内存会被占满，甚至还可能导致系统崩溃。

另外，在释放内存空间时，如果忘记初始化指向释放对象的内存空间的指针，这个指针就会一直指向释放完毕的内存空间。因为这个指针没有指向有效的内存空间，处于一种悬挂的状态，所以我们称其为“悬垂指针”（dangling pointer）。如果在程序中错误地引用了悬垂指针，就会产生无法预期的 BUG。此外，悬垂指针也会导致严重的安全漏洞（2009 年 IE6/7 的零日漏洞曾轰动一时。——丁灵注） 。

更有甚者，还可能会出现错误释放了使用中的内存空间的情况。一旦错误释放了使用中的内存空间，下一次程序使用此空间时就会发生故障。大多数情况下会发生段错误，运气不好的话还可能引发恶性 BUG。

上述这样与内存相关的 BUG，其共通之处在于“难以确定 BUG 的原因”。我们都知道，与内存相关的 BUG 的潜在场所和 BUG 出现的场所在位置上（或者是时间上）不一致，所以很难确定 BUG 的原因。

有GC的世界

为了省去上述手动内存管理的麻烦，人们钻研开发出了 GC。如果把内存管理交给计算机，程序员就不用去想着释放内存了。在手动内存管理中，程序员要判断哪些是不用的内存空间（垃圾），留意内存空间的寿命。但只要有 GC 在，这一切都可以交给 GC 来做。

有了 GC，程序员就不用再去担心因为忘了释放内存等而导致 BUG，从而大大减轻了负担。也不用再去头疼费事的内存管理。GC 能让程序员告别恼人的内存管理，把精力集中在更本质的编程工作上。

GC的历史

GC 是一门古老的技术

据笔者所知，GC 因为 Java 的发布而一举成名，所以很多人可能会认为 GC 是最近才有的技术。不过 GC 有着非常久远的历史，最初的 GC 算法是 John McCarthy 在 1960 年发布的。

John McCarthy 身为 Lisp 之父和人工智能之父，是一名非常有名的黑客，事实上他同时也是 GC 之父。1960 年，McCarthy 在其论文中首次发布了 GC 算法。当然，当时还没有 Garbage Collection 这个词。在这篇论文中发布的算法，就是现在我们所说的 GC 标记 - 清除算法。

引用计数法

1960 年，George E. Collins 在论文中发布了称为引用计数的 GC 算法。当时 Collins 可能没有注意到，引用计数法有个缺点，就是它不能回收“循环引用”。Harold McBeth在 1963 年指出了这个缺点。

GC 复制算法

1963 年，也有“人工智能之父”之称的 Marvin L. Minsky 在论文中发布了复制算法。GC 复制算法把内存分成了两部分，这篇论文中将第二部分称为磁带存储空间——不得不说带有浓烈的时代色彩。

50 年来，GC 的根本都没有改变

从 50 年前 GC 算法首次发布以来，众多研究者对其进行了各种各样的研究，因此许多 GC 算法也得以发布。但事实上，这些算法只不过是把前文中提到的三种算法进行组合或应用。也可以这么说，1963 年 GC 复制算法诞生时，GC 的根本性内容就已经完成了。

未知的第四种算法

现在为世人所知的 GC 算法，不过是从之前介绍的三种基本算法中衍生出来的产物。

本书中除了细致介绍这些基本的 GC 算法，还会介绍应用到它们的 GC 算法。把这些算法全看完后，请跟笔者一起，就 GC 的课题进行思考。也许发现全新的第四种基本算法的人，就是你。

为什么我们现在要学 GC

有以下几个原因。

1、GC—— 存在即合理

现在我们使用的多数编程语言都搭载有 GC。以下是几个具体的例子。

Lisp
Java
Ruby
Python
Perl
Haskell
大家有没有用过其中的某种编程语言？如果用过，那你在不知不觉中获得了 GC 带来的好处。

对编程语言来说，GC 就是一个无名英雄，默默地做着贡献。打个比方，天鹅在水面优雅地游动时，实际上脚蹼却在水下拼命地划水。GC 也是如此。在由编程语言构造的美丽的源代码这片水下，GC 在拼命地将垃圾回收再利用。

如上所述，GC 是语言处理程序中非常重要的一部分，相当于树荫。应该有很多人感觉“GC 帮忙回收垃圾是理所当然”的吧？

GC 基本上是高负载处理，需要花费一定的时间。打个比方，当编写像动作游戏这样追求即时性的程序时，就必须尽量压低 GC 导致的最大暂停时间。如果因为 GC 导致玩家频繁卡顿，相信谁都会想摔手柄。碰到这种应用，我们就需要选择最大暂停时间较短的 GC 算法了。

再打个比方，对音乐和动画这样类似于编码应用的程序来说，GC 的最大暂停时间就不那么重要了。更为重要的是，我们必须选择一个整体处理时间更短的算法。

笔者深信，事先知道“这个 GC 算法有这样的特征，所以它适合这个应用”对程序员来说很有价值。

2、多种多样的处理程序的实现

近年来，随着编程语言的发展，燃起了一股发布语言处理程序的势头，这些语言处理程序都搭载有不同的 GC 算法。作为语言处理程序的关键功能，很多人将采用了优秀的 GC 算法作为一大卖点。

GC 性能在语言处理程序的性能评价中也是一大要素。为了正确评价 GC 的性能，对 GC 算法的理解是不可或缺的。

3、留意内存空间的用法

应该有不少人是通过使用搭载 GC 的编程语言来学习编程的吧。本书的作者之一中村也是如此，他最初接触的编程语言是 Java。可以说在用 Java 语言编写程序时完全不用留意内存空间的用法。当然这也是多亏了 GC，这是好事，但太不留心也会招致麻烦。例如，有时会出现无意中把内存空间挥霍一空的情况，比如在循环中生成一些没用的对象等。这是因为没有把握好编程语言背后的内存管理的概念。

本书中以具体的编程语言为例，来说明编程语言中所使用的内存空间的结构，以及 GC 的运行。通过阅读，我们就能在编程中留意内存空间的用法了。

4、不会过时的技术

GC 自 1960 年发布以来，一直在吸引着顶尖工程师的目光。笔者确信，只要计算机构造不发生根本性的改变，GC 就是一门不会过时的技术。对程序员来说，比起学习日新月异的新技术，学习 GC 这样的古典技术不是更幸福吗？

5、更何况，GC 很有趣

说实话，其实笔者自己学习 GC 的时候，并没有想过上述这些略复杂的事情，只是纯粹觉得有趣。现在回过头觉得学了 GC 真好，也只是因为它具备前面那些优点。

笔者小时候就喜欢拆点什么东西，看看里面是怎样的。电视机、收音机、红白机什么的都拆了个遍。笔者至今都还记得看到其内部时的快感，以及了解其构造时的感动。或许学习 GC 也差不多是这样。对笔者来说，研究 GC 这种理所当然存在的东西，看看它的内部是一件非常刺激的事。

6、读者对象

本书由两部分构成。

算法篇
实现篇
在“算法篇”中，我们没有必要去详细了解特定的编程语言，你只要能用任何一种语言编程，就能往下读“算法篇”。

阅读“实现篇”需要具备 C 和 C++ 的知识。只要会用 C 的函数指针、C++ 的模板，阅读“实现篇”就没有什么障碍。关于 GC 算法的知识，读完本书的“算法篇”就相当够用了。

“实现篇”中涉及各种编程语言{ Python / Java / Ruby / JavaScript }，最好有一定程度的了解，那样阅读起来会比较轻松。

垃圾回收的算法与实现

这里写图片描述

ガベージコレクションのアルゴリズムと実装 
作者：中村成洋 相川光 
译者：丁灵 
定价：99（各大网店可购买） 
电子书：49.99（点击目录购买电子书）

Ruby之父松本行弘推荐，日本天才程序员兼LISP黑客竹内郁雄审校
254幅图解，轻松掌握GC经典算法
实际源码剖析，深入探讨GC具体实现
本书分为“算法篇”和“实现篇”两大部分。算法篇介绍了标记–清除算法、引用计数法、复制算法、标记–压缩算法、保守式GC、分代垃圾回收、增量式垃圾回收、RC Immix算法等几种重要的算法；实现篇介绍了垃圾回收在Python、DalvikVM、Rubinius、V8等几种语言处理程序中的具体实现。本书适合各领域程序员阅读。