>读完本文你将了解到：

>- 什么是二叉排序树（即 B 树、二叉查找树、二叉搜索树）
>- 二叉排序树的关键操作
- 二叉排序树的优点缺点及使用场景
>- Java 实现一个二叉排序树
>- 二叉排序树的常见面试题

##什么是二叉排序树 Binary Sort Tree, BST

二叉排序树，又称二叉查找树、二叉搜索树、B树。

二叉排序树是具有下列性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；

![这里写图片描述](http://img.blog.csdn.net/20161031182149529)

##二叉排序树的关键操作

###1.查找

###2.插入

###3.删除

插入操作和查找比较类似，也比较的简单，而删除的时候需要根据删除节点的情况分类来对待：
　　(1). 如果要删除的节点是叶子节点，其没有任何子树，那么就直接删除之；
　　(2). 如果要删除的节点仅有左子树或者仅有右子树，那么就将其对应的左子树或者右子树这个非空子树整个移动到删除节点的位置，以完成独子承父业；
　　(3). 如果要删除的节点其左右子树都有节点，具体的做法可以选择：
　　　　a. 要么沿着要删除节点的左子树，一直向右走，找出最右的节点，取出来替换该删除节点；
　　　　b. 或者沿着删除节点的右子树，一直向左走，找出最左的节点，然后替换之。
　　上面最后一种情况的删除原理，其实就是寻找待删除节点大小最相临的前驱或后驱来直接替代它，替代后整个二叉树还是保持有序的状态，同时替换的节点由于是选择的最左或者最右节点，其最多也就只有一个子数，所以替换节点的删除本身也是十分方便的，采用上面(2)的情况处理就可以了。
　　二叉树的性能取决于二叉树的层数，最好的情况是O(logn)，存在于完全二叉树情况下，其访问性能近似于折半查找；最差时候会是O(n)，比如在斜树的情况下，需要逐个遍历二叉树的元素才行。

##平衡二叉树

前面说到，二叉树的查找、插入、删除操作的性能十分依赖于树的高度，所以如果能把树维持在一个完全二叉树的情况下，当然是最理想最高效的情况，所以在增加和删除这种会修改二叉树结构的操作中，能检测修改后的二叉树状态并修正之，限制二叉树的高度，即为平衡二叉树。

##Thanks

https://taozj.org/2016/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AAVL%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

http://blog.csdn.net/v_JULY_v/article/details/6530142/
http://blog.csdn.net/v_july_v/article/details/6543438

http://baike.baidu.com/link?url=gGnlVdkdSIFg9RINW2I9PC-H26Vonbo4yOH0wiCgGzBoVb540EBqF2-5ho1Sx2ImSckufU8WeiFjTRnL0Mu648kVIJHhaIfiOx5CKgKtDPrNhiAJ5lQ0CFhWoe-CWRAf-sIQJZHZdAysqGIgHfsga_