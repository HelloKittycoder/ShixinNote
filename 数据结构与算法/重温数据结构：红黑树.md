
读完本文你将了解到：

[TOC]

排序二叉树虽然可以快速检索，但在最坏的情况下：如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很差。

为了改变排序二叉树存在的不足，Rudolf Bayer 与 1972 年发明了另一种改进后的排序二叉树：红黑树，他将这种排序二叉树称为“对称二叉 B 树”，而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出。

本文介绍了红黑树的基本性质和基本操作。

##什么是红黑树
红黑树是一种自平衡二叉查找树。它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。

在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。

它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。


##红黑树的 5 个特性

![shixinzhang](http://img.blog.csdn.net/20161123195416588)


红黑树在原有的排序二叉树增加了如下几个要求：

1. Every node is either red or black.
2. The root is black.
3. Every leaf (NIL) is black.
4. If a node is red, then both its children are black.
5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.

中文意思是：

1. 每个节点要么是红色，要么是黑色。
2. 根节点永远是黑色的。
3. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是 上图中的 NIL）。
4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）
5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点

上面的性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。



##红黑树的左旋右旋

![shixinzhang](http://img.blog.csdn.net/20161122151257178)

左右旋的目的是在保证排序树的性质前提下，调整红黑节点结构。

比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。

讲完原理，拿 TreeMap 的 rotateLeft 代码解释

指定节点 x 的左旋 (右图转成左图)：

    private void rotateLeft(Entry<K,V> p) {
        if (p != null) {
            Entry<K,V> r = p.right;	// p 是上图中的 x，r 就是 y
            p.right = r.left;		// y 的左子树 β 变成了 x 的右子树
            if (r.left != null)			
                r.left.parent = p;	//
            r.parent = p.parent;
            if (p.parent == null)
                root = r;
            else if (p.parent.left == p)
                p.parent.left = r;
            else
                p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }

指定节点 p 的右旋：

    private void rotateRight(Entry<K,V> p) {
        if (p != null) {
            Entry<K,V> l = p.left;
            p.left = l.right;
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
            if (p.parent == null)
                root = l;
            else if (p.parent.right == p)
                p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }


##红黑树的平衡插入

- 首先和二叉树的插入一样，查找、插入
- 然后调整结构，保证满足红黑树状态
 - 对结点进行重新着色
 - 以及对树进行相关的旋转操作

红黑树的插入相当于在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。

###二叉树的插入
###调整结构
####调整思想

参考这个 http://blog.csdn.net/mariofei/article/details/18922377

####根据 TreeMap 的代码来验证这个过程：

    private void fixAfterInsertion(Entry<K,V> x) {
        x.color = RED;

        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                Entry<K,V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                Entry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }


##红黑树的平衡删除

###二叉树的删除

三种情况，

第三种
（图来自：http://shmilyaw-hotmail-com.iteye.com/blog/1836431）
![shixinzhang](http://img.blog.csdn.net/20161122161156641)

###删除后的结构调整

###调整思想

根据红黑树的第 5 个特性：

如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。
而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。

新节点的颜色可能影响

删除黑色节点后，需要想办法调整结构，使得从根部到任何节点上的黑色节点个数保持一致。

为了保证左右黑色节点一致，都是当前节点和兄弟节点对比

以当前节点为父节点的左孩子为例进行分析。

**第一步：**

- 兄弟如果是红的，说明孩子都是黑的 **【旋转的情况 1 】**
 - 把兄弟搞成黑的
 - 父亲搞成红的
 - 左旋转父亲（嘿嘿，给我分一个黑孩子）
 - 接下来对比旋转后的兄弟 

**第一步解释：**

这一步的目的是将树转变成第二步两种情形中的某一种情况。

在做后续变化前，这棵树还是保持着原来的平衡。


**第二步：**

情况1 ：**兄弟节点的孩子都是黑色**

 - 把兄弟搞成红的
 - continue 下一波（这个子树搞完了，研究父亲节点，去搞上一级树，进入第三步）

**第二步情况 1 解释：**

因为我们假定A节点是要调整的节点一路调整过来的。因为原来那个要调整的节点为黑色，它一旦被删除就路径上的黑色节点少了1.所以这里A所在的路径都是黑色节点少1.这里将A的兄弟节点变成红色后，从它的父节点到下面的所有路径就都统一少了1.保证最后又都平衡了。

![shixinzhang](http://img.blog.csdn.net/20161123181139013)

情况2 ：**兄弟节点的孩子至多有一个是黑的**

 -  把不是黑的那个孩子搞黑  **【旋转的情况 2 】**
  -  兄弟搞红
  -  兄弟右旋转
  -  以后对比旋转后的兄弟
 - 把兄弟涂成跟父亲一样的颜色 **【旋转的情况 3 】**
 - 然后把父亲搞黑
 - 把兄弟的右孩子搞黑
 - 父亲节点左旋
 - 研究根节点，进入第三步

**第二步情况 2 解释：**

旋转的情况 2 是将兄弟节点的左右孩子都移动到右边，方便后续操作，如下图所示：

![shixinzhang](http://img.blog.csdn.net/20161123191629854)

旋转的情况 3 将兄弟的孩子移到左边来，同时父亲变到了左边（总之就是让左边多些黑色节点），如下图所示：

![shixinzhang](http://img.blog.csdn.net/20161123191513353)


第三步：

- 如果研究的不是根节点并且是黑的，重新进入第一步，研究上一级树；
- 如果研究的是根节点或者这个节点不是黑的，就退出
 - 把研究的这个节点涂成黑的。

**第三步解释：**

在做了那个将兄弟节点置成红色的操作之后，从父节点B开始的所有子节点都少了1.那么这里从代码中间看的话，由于x指向了父节点，仍然是黑色。则这个时候以父节点B作为基准的子树下面都少了黑节点1. 我们就接着以这么一种情况向上面推进。

为什么这一步调整结束后就直接x = T.root了呢？也就是说我们一走完这个就可以把x直接跳到根节点，其他的都不需要看了。

这是因为我们前面的一个前提，A节点向上所在的路径都是黑色节点少了一个的，这里我们以调整之后相当于给它增加了一个黑色节点，同时对其他子树的节点没有任何变化。相当于我内部已经给它补偿上来了。所以后续就不需要再往上去调整。

当然，大家还会有一个担忧，就是当前调整的毕竟只是一棵树中间的字数，这里头的节点B可能还有父节点，这么一直往上到根节点。你这么一棵字数少了一个黑色节点，要保证整理合格还是不够的。这里在代码里有了一个保证。假设这里B已经是红色的了。那么代码里那个循环块就跳出来了，最后的部分还是会对B节点，也就是x所指向的这个节点置成黑色。这样保证前面亏的那一个黑色节点就补回来了。


###总结上面做了什么？

1.

2.三次旋转

前面讨论的这4种情况是在当前节点是父节点的左子节点的条件下进行的。如果当前节点是父节点的右子节点，则可以对应的做对称的操作处理，过程也是一样的。

其中具体旋转方向根据调整节点在父节点的左/右位置决定。



####根据 TreeMap 的代码来验证这个过程：

    private void fixAfterDeletion(Entry<K,V> x) {
        while (x != root && colorOf(x) == BLACK) {
            if (x == leftOf(parentOf(x))) {
                Entry<K,V> sib = rightOf(parentOf(x));

				//左旋，把黑色节点移到左边一个
                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                if (colorOf(leftOf(sib))  == BLACK &&
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } else { //处理的节点在 右边，相同逻辑，只不过旋转的方向相反
                Entry<K,V> sib = leftOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                if (colorOf(rightOf(sib)) == BLACK &&
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(leftOf(sib), BLACK);
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
    }

当调整的节点属于父亲节点的左子树时，调整方法对应的流程图如下：

![shixinzhang](http://img.blog.csdn.net/20161123154156508)

当调整的节点属于父亲节点的右子树时，调整方法也类似，旋转的方向相对称。

这里列出**删除后调整的全部逻辑流程图**（右键新窗口打开图片更清晰）：

![shixinzhang](http://img.blog.csdn.net/20161123193345472)

##总结

红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。


在线演示添加、删除红黑树：

http://sandbox.runjs.cn/show/2nngvn8w

##Thanks

《算法导论》

http://en.wikipedia.org/wiki/Red–black_tree

http://www.cnblogs.com/skywang12345/p/3245399.html

http://shmilyaw-hotmail-com.iteye.com/blog/1836431

http://blog.csdn.net/speedme/article/details/18743445

http://blog.csdn.net/eson_15/article/details/51144079

http://blog.csdn.net/v_july_v/article/details/6105630

http://dongxicheng.org/structure/red-black-tree/